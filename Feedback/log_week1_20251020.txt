======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Qianwen Liu

Processing week 1

Your current Git repo size is about 9.70 MiB on disk

Found directories: .git, week1, week2, Feedback, week3
Found files: .pre-commit-config.yaml, .gitignore, sys, README.md

Processing week 1: week1

Found 9 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/sh

#Process one file each time

echo "Usage: $0 <file>"
echo "Please provide correct csv relative path."
if [ $# -ne 1 ]; then
    echo "Error: This script requires exactly one input file."
    exit 1
fi

# Check if input file exists
if [ ! -f "$1" ]; then
    echo "Error: File '$1' not found!"
    echo "Please check if the file exists."
    exit 1
fi

filename=$(basename "$1")
echo "Creating a comma delimited version of $1 ..."
# Create the output file since >> will not create a new file
cat $1 | tr "," " " > ../results/output_$filename
echo "Done!"
exit
**********

Output (first 500 chars):

**********
Usage: csvtospace.sh <file>
Please provide correct csv relative path.
Error: This script requires exactly one input file.

**********
No errors.
======================================================================
Script: CompileLaTeX.sh

Contents:

**********
#!/bin/bash

# Remove .tex extension if present
# Check if exactly one argument is provided
if [ $# -ne 1 ]; then
    echo "Error: Please input file name"
    echo "Example:bash $0 document.tex"
    exit 1
fi
filename=$(basename "$1" .tex)

pdflatex $filename.tex
bibtex $filename
pdflatex $filename.tex
pdflatex $filename.tex
evince $filename.pdf &

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg
**********

Output (first 500 chars):

**********
Error: Please input file name
Example:bash CompileLaTeX.sh document.tex

**********
No errors.
======================================================================
Script: tiff2png.sh

Contents:

**********
# !/bin/bash

# transform all .tif files in ../data/image_convert/ to .png files in results directory

for f in ../data/image_convert/*.tif; 
    do  
        echo "Converting $f"; 
        convert "$f" "../results/$(basename "$f" .tif).png"; 
    done
**********

Output (first 500 chars):

**********
Converting ../data/image_convert/file_example_TIFF_10MB.tif
Converting ../data/image_convert/file_example_TIFF_1MB.tif
Converting ../data/image_convert/file_example_TIFF_5MB.tif

**********
No errors.
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: Betty Liu qql25@ic.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2025

echo -e "\nThis is a shell script! \n"

exit 1

**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: ConcatenateTwoFiles.sh

Contents:

**********
# !/bin/bash

echo "Usage: $0 <file1> <file2> <output_file>"
echo "Please provide correct relative paths for all files."
# Check if exactly two arguments are provided
if [ $# -ne 3 ]; then
    echo "Error: This script requires exactly two input files and one output file."
    exit 1
fi

cat $1 > $3
cat $2 >> $3
echo "Merged File is"
cat $3
**********

Output (first 500 chars):

**********
Usage: ConcatenateTwoFiles.sh <file1> <file2> <output_file>
Please provide correct relative paths for all files.
Error: This script requires exactly two input files and one output file.

**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: Betty Liu qql25@ic.ac.uk
# Script: tabtocsv.sh
# Description: substitute the tabs in the files with commas
#
# Saves the output into a .csv file
# Arguments: 1 -> tab delimited file
# Date: Oct 2025

echo "Usage: $0 <file>"
echo "Please provide correct relative path."
if [ $# -ne 1 ]; then
    echo "Error: This script requires exactly one input file."
    exit 1
fi

filename=$(basename "$1")
echo "Creating a comma delimited version of $1 ..."
# Create the output file since >> will not create a new file
cat $1 | tr -s "\t" "," > ../results/$filename.csv
echo "Done!"
exit
**********

Output (first 500 chars):

**********
Usage: tabtocsv.sh <file>
Please provide correct relative path.
Error: This script requires exactly one input file.

**********
No errors.
======================================================================
Script: MyExampleScript.sh

Contents:

**********
#!/bin/sh

# Using 2 ways to print Hello <username>
MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"
echo "Hello $USER"
echo
**********

Output (first 500 chars):

**********
Hello mhasoba
Hello mhasoba


**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
# !/bin/sh

## Illustrates the use of variables 

# Special variables

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

# Assigned Variables; Explicit declaration:
MY_VAR='some string' 
echo 'the current value of the variable is:' $MY_VAR
echo
echo 'Please enter a new string'
read MY_VAR
echo
echo 'the current value of the variable is:' $MY_VAR
echo

## Assigned Variables; Reading (multiple values) from user input:
echo 'Enter two numbers separated by space(s)'
read a b
# Check if both a and b were provided - exit immediately if not
if [ -z "$a" ] || [ -z "$b" ]; then
    echo "Error: You must enter two numbers!"
    exit 1
fi
echo 'you entered' $a 'and' $b '; Their sum is:'

## Assigned Variables; Command substitution
MY_SUM=$(expr $a + $b)
echo $MY_SUM
**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
the current value of the variable is: some string

Please enter a new string

the current value of the variable is:

Enter two numbers separated by space(s)
Error: You must enter two numbers!

**********
No errors.
======================================================================
Script: CountLines.sh

Contents:

**********
# !/bin/bash

echo "Usage: $0 <file>"
echo "Please provide correct relative paths for all files."
if [ $# -ne 1 ]; then
    echo "Error: This script requires exactly one input file."
    exit 1
fi

NumLines=`wc -l < $1`
echo "The file $1 has $NumLines lines"
echo
**********

Output (first 500 chars):

**********
Usage: CountLines.sh <file>
Please provide correct relative paths for all files.
Error: This script requires exactly one input file.

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 9
Scripts successful: 9
Scripts with errors: 0
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

